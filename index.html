<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>アリの巣シミュレーター（フェロモン付き）</title>
  <style>
    body {
      margin: 0;
      background: #111;
      color: #f5f5f5;
      font-family: "Segoe UI", sans-serif;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background: linear-gradient(to bottom, #4d3a28 15%, #2a1f14 15%);
    }
    .hud {
      position: fixed;
      inset: 16px auto auto 16px;
      padding: 8px 12px;
      border-radius: 6px;
      background: rgba(17, 17, 17, 0.65);
      backdrop-filter: blur(6px);
      border: 1px solid rgba(255, 255, 255, 0.05);
      font-size: 13px;
      line-height: 1.4;
    }
    .hud strong {
      color: #ffe066;
    }
  </style>
</head>
<body>
  <canvas id="antCanvas"></canvas>
  <div class="hud" id="hud"></div>
  <script>
    const canvas = document.getElementById("antCanvas");
    const ctx = canvas.getContext("2d");
    const hud = document.getElementById("hud");

    const CONFIG = Object.freeze({
      initialAnts: 18,
      maxAnts: 220,
      maxTunnels: 1400,
      maxPheromones: 2100,
      pheromoneDecay: 0.97,
      pheromoneThreshold: 0.04,
      pheromoneSenseDistance: 56,
      pheromoneDropChance: 0.45,
      exploreTurnRate: 0.18,
      exploreSpeed: 1.05,
      returnSpeed: 1.6,
      queenLayInterval: 220,
      queenLayIntervalJitter: 140,
      foodClusterMin: 4,
      foodClusterMax: 11,
      foodRadiusBase: 5,
      foodSpawnInterval: 600,
      maxFoodSources: 4,
      expansionBaseCost: 12,
      expansionCostGrowth: 6,
    });

    let viewWidth = 0;
    let viewHeight = 0;
    let surfaceHeight = 0;

    const ants = [];
    const tunnels = [];
    const rooms = [];
    const pheromones = [];
    const foods = [];

    const colony = {
      foodBank: 0,
      expansionProgress: 0,
      nextExpansionCost: CONFIG.expansionBaseCost,
    };

    const queen = {
      x: 0,
      y: 0,
      layTimer: CONFIG.queenLayInterval,
    };

    let foodSpawnTimer = CONFIG.foodSpawnInterval;

    function limitArraySize(array, maxLength) {
      if (array.length > maxLength) {
        array.splice(0, array.length - maxLength);
      }
    }

    function spawnAnt(x, y) {
      ants.push({
        x,
        y,
        angle: Math.random() * Math.PI * 2,
        state: "explore",
        carrying: false,
        cargo: 0,
      });
    }

    function dropPheromone(x, y) {
      if (pheromones.length >= CONFIG.maxPheromones) {
        pheromones.shift();
      }
      pheromones.push({ x, y, strength: 1 });
    }

    function updatePheromones() {
      pheromones.forEach(p => (p.strength *= CONFIG.pheromoneDecay));
      for (let i = pheromones.length - 1; i >= 0; i--) {
        if (pheromones[i].strength < CONFIG.pheromoneThreshold) {
          pheromones.splice(i, 1);
        }
      }
    }

    function spawnFoodSource() {
      if (viewWidth === 0) return;
      const amount = CONFIG.foodClusterMin + Math.floor(Math.random() * (CONFIG.foodClusterMax - CONFIG.foodClusterMin + 1));
      const margin = viewWidth * 0.1;
      const x = margin + Math.random() * Math.max(40, viewWidth - margin * 2);
      const y = surfaceHeight * (0.35 + Math.random() * 0.25);
      const radius = CONFIG.foodRadiusBase + Math.sqrt(amount) * 1.1;
      foods.push({ x, y, radius, amount });
    }

    function updateFoodSpawning() {
      if (foods.length >= CONFIG.maxFoodSources) {
        foodSpawnTimer = CONFIG.foodSpawnInterval;
        return;
      }
      foodSpawnTimer--;
      if (foodSpawnTimer <= 0) {
        spawnFoodSource();
        foodSpawnTimer = CONFIG.foodSpawnInterval + Math.floor(Math.random() * CONFIG.foodSpawnInterval);
      }
    }

    function initializeNest() {
      const nursery = { x: queen.x, y: queen.y + 32, radius: 28 };
      const leftChamber = { x: queen.x - 92, y: queen.y + 86, radius: 22 };
      const rightChamber = { x: queen.x + 92, y: queen.y + 86, radius: 22 };
      rooms.push(nursery, leftChamber, rightChamber);
      tunnels.push(
        { x1: queen.x, y1: queen.y, x2: nursery.x, y2: nursery.y },
        { x1: nursery.x, y1: nursery.y, x2: leftChamber.x, y2: leftChamber.y },
        { x1: nursery.x, y1: nursery.y, x2: rightChamber.x, y2: rightChamber.y },
      );
    }

    function maybeExpandNest() {
      if (colony.expansionProgress < colony.nextExpansionCost || rooms.length === 0) return;
      colony.expansionProgress -= colony.nextExpansionCost;
      colony.nextExpansionCost += CONFIG.expansionCostGrowth;

      const angle = Math.PI * (0.35 + Math.random() * 0.3) + (rooms.length % 2 === 0 ? 0 : Math.PI / 6);
      const distance = 120 + rooms.length * 18;
      const direction = Math.random() < 0.5 ? -1 : 1;
      const x = rooms[0].x + Math.cos(angle) * distance * direction;
      const y = rooms[0].y + Math.sin(angle) * (distance * 0.9);
      const radius = 18 + Math.random() * 9;
      const newRoom = { x, y, radius };
      rooms.push(newRoom);
      tunnels.push({ x1: rooms[0].x, y1: rooms[0].y, x2: newRoom.x, y2: newRoom.y });
      limitArraySize(tunnels, CONFIG.maxTunnels);
    }

    function updateQueen() {
      queen.layTimer--;
      if (queen.layTimer <= 0) {
        if (ants.length < CONFIG.maxAnts && colony.foodBank > 0) {
          colony.foodBank--;
          spawnAnt(queen.x + (Math.random() - 0.5) * 12, queen.y + (Math.random() - 0.5) * 12);
        }
        queen.layTimer = CONFIG.queenLayInterval + Math.random() * CONFIG.queenLayIntervalJitter;
      }
    }

    function updateAnts() {
      const minX = 4;
      const maxX = Math.max(minX, viewWidth - 4);
      const minY = surfaceHeight + 12;
      const maxY = Math.max(minY, viewHeight - 12);

      ants.forEach(ant => {
        if (ant.state === "explore") {
          let best = null;
          let bestStrength = 0;
          for (let i = pheromones.length - 1; i >= 0; i--) {
            const p = pheromones[i];
            const dx = p.x - ant.x;
            const dy = p.y - ant.y;
            const dist = Math.hypot(dx, dy);
            if (dist < CONFIG.pheromoneSenseDistance && p.strength > bestStrength) {
              best = p;
              bestStrength = p.strength;
            }
          }
          if (best) {
            ant.angle = Math.atan2(best.y - ant.y, best.x - ant.x);
            ant.angle += (Math.random() - 0.5) * (CONFIG.exploreTurnRate * 0.3);
          } else {
            ant.angle += (Math.random() - 0.5) * CONFIG.exploreTurnRate;
          }

          ant.x += Math.cos(ant.angle) * CONFIG.exploreSpeed;
          ant.y += Math.sin(ant.angle) * CONFIG.exploreSpeed;

          if (ant.y < minY) ant.y = minY;
          if (ant.x < minX) ant.x = minX;
          if (ant.x > maxX) ant.x = maxX;
          if (ant.y > maxY) ant.y = maxY;

          if (Math.random() < 0.0025) {
            const length = 10 + Math.random() * 14;
            const angle = ant.angle + (Math.random() - 0.5) * 0.6;
            tunnels.push({
              x1: ant.x,
              y1: ant.y,
              x2: ant.x + Math.cos(angle) * length,
              y2: ant.y + Math.sin(angle) * length,
            });
            limitArraySize(tunnels, CONFIG.maxTunnels);
          }

          for (let i = foods.length - 1; i >= 0; i--) {
            const f = foods[i];
            if (f.amount <= 0) continue;
            const dist = Math.hypot(f.x - ant.x, f.y - ant.y);
            if (dist < f.radius + 2) {
              ant.carrying = true;
              ant.cargo = 1;
              ant.state = "return";
              f.amount--;
              if (f.amount <= 0) {
                foods.splice(i, 1);
              }
              break;
            }
          }
        } else {
          const dx = queen.x - ant.x;
          const dy = queen.y - ant.y;
          ant.angle = Math.atan2(dy, dx);
          ant.x += Math.cos(ant.angle) * CONFIG.returnSpeed;
          ant.y += Math.sin(ant.angle) * CONFIG.returnSpeed;

          if (Math.random() < CONFIG.pheromoneDropChance) {
            dropPheromone(ant.x, ant.y);
          }

          const dist = Math.hypot(dx, dy);
          if (dist < 10) {
            ant.carrying = false;
            colony.foodBank += ant.cargo;
            colony.expansionProgress += ant.cargo;
            ant.cargo = 0;
            ant.state = "explore";
            maybeExpandNest();
          }
        }
      });
    }

    function draw() {
      ctx.clearRect(0, 0, viewWidth, viewHeight);

      ctx.fillStyle = "#4d3a28";
      ctx.fillRect(0, 0, viewWidth, surfaceHeight);

      ctx.fillStyle = "#2a1f14";
      ctx.fillRect(0, surfaceHeight, viewWidth, viewHeight - surfaceHeight);

      ctx.strokeStyle = "#3b2f1c";
      ctx.lineWidth = 2;
      tunnels.forEach(t => {
        ctx.beginPath();
        ctx.moveTo(t.x1, t.y1);
        ctx.lineTo(t.x2, t.y2);
        ctx.stroke();
      });

      rooms.forEach(r => {
        ctx.beginPath();
        ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2);
        ctx.fillStyle = "#3a2a1c";
        ctx.fill();
      });

      pheromones.forEach(p => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 1.6, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(0, 200, 220, ${p.strength})`;
        ctx.fill();
      });

      foods.forEach(f => {
        ctx.beginPath();
        ctx.arc(f.x, f.y, Math.max(2, f.radius * (f.amount / CONFIG.foodClusterMax + 0.2)), 0, Math.PI * 2);
        ctx.fillStyle = "#0f0";
        ctx.fill();
      });

      ctx.beginPath();
      ctx.arc(queen.x, queen.y, 7, 0, Math.PI * 2);
      ctx.fillStyle = "#f0c";
      ctx.fill();

      ants.forEach(ant => {
        ctx.beginPath();
        ctx.arc(ant.x, ant.y, ant.carrying ? 2.6 : 2.2, 0, Math.PI * 2);
        ctx.fillStyle = ant.carrying ? "#ff0" : "#fff";
        ctx.fill();
      });
    }

    function updateHud() {
      hud.innerHTML = `
        <strong>女王</strong> 体力: ${colony.foodBank.toString().padStart(2, "0")} / 巣部屋: ${rooms.length}<br>
        アリ: ${ants.length} / ${CONFIG.maxAnts}　フェロモン: ${pheromones.length}　食料源: ${foods.length}
      `;
    }

    function resizeCanvas(initial = false) {
      const prevWidth = viewWidth || window.innerWidth;
      const prevHeight = viewHeight || window.innerHeight;
      const dpr = window.devicePixelRatio || 1;

      viewWidth = window.innerWidth;
      viewHeight = window.innerHeight;
      surfaceHeight = viewHeight * 0.15;

      canvas.style.width = `${viewWidth}px`;
      canvas.style.height = `${viewHeight}px`;
      canvas.width = viewWidth * dpr;
      canvas.height = viewHeight * dpr;
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.scale(dpr, dpr);

      if (initial) {
        queen.x = viewWidth / 2;
        queen.y = surfaceHeight + 60;
        return;
      }

      const scaleX = viewWidth / prevWidth;
      const scaleY = viewHeight / prevHeight;

      ants.forEach(ant => {
        ant.x *= scaleX;
        ant.y *= scaleY;
      });
      tunnels.forEach(t => {
        t.x1 *= scaleX;
        t.y1 *= scaleY;
        t.x2 *= scaleX;
        t.y2 *= scaleY;
      });
      rooms.forEach(r => {
        r.x *= scaleX;
        r.y *= scaleY;
        r.radius *= (scaleX + scaleY) * 0.5;
      });
      pheromones.forEach(p => {
        p.x *= scaleX;
        p.y *= scaleY;
      });
      foods.forEach(f => {
        f.x *= scaleX;
        f.y *= scaleY;
        f.radius *= (scaleX + scaleY) * 0.5;
      });

      queen.x *= scaleX;
      queen.y = surfaceHeight + 60;
    }

    function animate() {
      updateQueen();
      updateAnts();
      updatePheromones();
      updateFoodSpawning();
      draw();
      updateHud();
      requestAnimationFrame(animate);
    }

    function bootstrap() {
      resizeCanvas(true);
      initializeNest();
      for (let i = 0; i < CONFIG.initialAnts; i++) {
        spawnAnt(queen.x + (Math.random() - 0.5) * 30, queen.y + (Math.random() - 0.5) * 30);
      }
      for (let i = 0; i < 2; i++) {
        spawnFoodSource();
      }
      animate();
    }

    window.addEventListener("resize", () => resizeCanvas(false));
    bootstrap();
  </script>
</body>
</html>
