<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>アリの巣シミュレーター（フェロモン付き）</title>
  <style>
    body {
      margin: 0;
      background: #111;
      color: #f5f5f5;
      font-family: "Segoe UI", sans-serif;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background: #111;
    }
    .hud {
      position: fixed;
      inset: 16px auto auto 16px;
      padding: 8px 12px;
      border-radius: 6px;
      background: rgba(17, 17, 17, 0.7);
      border: 1px solid rgba(255, 255, 255, 0.05);
      font-size: 13px;
      line-height: 1.4;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
    }
    .hud strong {
      color: #ffe066;
    }
  </style>
</head>
<body>
  <canvas id="antCanvas"></canvas>
  <div class="hud" id="hud"></div>
  <script>
    const canvas = document.getElementById("antCanvas");
    const ctx = canvas.getContext("2d");
    const hud = document.getElementById("hud");

    const CONFIG = Object.freeze({
      initialAnts: 18,
      maxAnts: 220,
      maxTunnels: 1400,
      maxPheromones: 2100,
      pheromoneDecay: 0.97,
      pheromoneThreshold: 0.04,
      pheromoneSenseDistance: 56,
      pheromoneDropChance: 0.45,
      exploreTurnRate: 0.18,
      exploreSpeed: 1.05,
      returnSpeed: 1.6,
      queenLayInterval: 220,
      queenLayIntervalJitter: 140,
      foodClusterMin: 4,
      foodClusterMax: 11,
      foodRadiusBase: 5,
      foodSpawnInterval: 600,
      maxFoodSources: 4,
      expansionBaseCost: 12,
      expansionCostGrowth: 6,
      trailMaxPoints: 480,
      trailRecordDistance: 4,
    });

    const VISUAL = Object.freeze({
      soilSpeckleDensity: 18000,
      soilSpeckleMax: 520,
      tunnelBaseWidth: 3.2,
      tunnelWidthVariance: 1.6,
      tunnelShadow: "rgba(11, 8, 6, 0.4)",
      roomHighlight: "rgba(255, 210, 140, 0.45)",
      queenAuraColor: "rgba(255, 105, 215, 0.18)",
      entranceGlow: "rgba(160, 120, 80, 0.55)",
    });

    let viewWidth = 0;
    let viewHeight = 0;
    let surfaceHeight = 0;

    const ants = [];
    const tunnels = [];
    const rooms = [];
    const pheromones = [];
    const foods = [];
    const soilSpeckles = [];

    const colony = {
      foodBank: 0,
      expansionProgress: 0,
      nextExpansionCost: CONFIG.expansionBaseCost,
    };

    const queen = {
      x: 0,
      y: 0,
      layTimer: CONFIG.queenLayInterval,
    };

    let foodSpawnTimer = CONFIG.foodSpawnInterval;

    function limitArraySize(array, maxLength) {
      if (array.length > maxLength) {
        array.splice(0, array.length - maxLength);
      }
    }

    function generateSoilTexture() {
      soilSpeckles.length = 0;
      const target = Math.min(
        VISUAL.soilSpeckleMax,
        Math.floor((viewWidth * (viewHeight - surfaceHeight)) / VISUAL.soilSpeckleDensity)
      );
      for (let i = 0; i < target; i++) {
        soilSpeckles.push({
          x: Math.random() * viewWidth,
          y: surfaceHeight + Math.random() * (viewHeight - surfaceHeight),
          length: 4 + Math.random() * 12,
          thickness: 0.6 + Math.random() * 0.8,
          angle: (Math.random() - 0.5) * Math.PI,
          alpha: 0.05 + Math.random() * 0.12,
        });
      }
    }

    function spawnAnt(x, y) {
      ants.push({
        x,
        y,
        angle: Math.random() * Math.PI * 2,
        state: "explore",
        carrying: false,
        cargo: 0,
        trail: [{ x, y }],
        trailLastRecord: { x, y },
        pathIndex: -1,
      });
    }

    function dropPheromone(x, y) {
      if (pheromones.length >= CONFIG.maxPheromones) {
        pheromones.shift();
      }
      pheromones.push({ x, y, strength: 1 });
    }

    function updatePheromones() {
      pheromones.forEach(p => (p.strength *= CONFIG.pheromoneDecay));
      for (let i = pheromones.length - 1; i >= 0; i--) {
        if (pheromones[i].strength < CONFIG.pheromoneThreshold) {
          pheromones.splice(i, 1);
        }
      }
    }

    function spawnFoodSource() {
      if (viewWidth === 0) return;
      const amount = CONFIG.foodClusterMin + Math.floor(Math.random() * (CONFIG.foodClusterMax - CONFIG.foodClusterMin + 1));
      const margin = viewWidth * 0.1;
      const x = margin + Math.random() * Math.max(40, viewWidth - margin * 2);
      const y = surfaceHeight * (0.35 + Math.random() * 0.25);
      const radius = CONFIG.foodRadiusBase + Math.sqrt(amount) * 1.1;
      foods.push({ x, y, radius, amount });
    }

    function updateFoodSpawning() {
      if (foods.length >= CONFIG.maxFoodSources) {
        foodSpawnTimer = CONFIG.foodSpawnInterval;
        return;
      }
      foodSpawnTimer--;
      if (foodSpawnTimer <= 0) {
        spawnFoodSource();
        foodSpawnTimer = CONFIG.foodSpawnInterval + Math.floor(Math.random() * CONFIG.foodSpawnInterval);
      }
    }

    function initializeNest() {
      const nursery = { x: queen.x, y: queen.y + 32, radius: 30, width: 6, type: "nursery" };
      const leftChamber = { x: queen.x - 92, y: queen.y + 86, radius: 26, width: 5, type: "storage" };
      const rightChamber = { x: queen.x + 92, y: queen.y + 86, radius: 24, width: 5, type: "storage" };
      rooms.push(nursery, leftChamber, rightChamber);
      tunnels.push(
        { x1: queen.x, y1: queen.y, x2: nursery.x, y2: nursery.y, width: 5.5 },
        { x1: nursery.x, y1: nursery.y, x2: leftChamber.x, y2: leftChamber.y, width: 4.4 },
        { x1: nursery.x, y1: nursery.y, x2: rightChamber.x, y2: rightChamber.y, width: 4.4 },
      );
    }

    function maybeExpandNest() {
      if (colony.expansionProgress < colony.nextExpansionCost || rooms.length === 0) return;
      colony.expansionProgress -= colony.nextExpansionCost;
      colony.nextExpansionCost += CONFIG.expansionCostGrowth;

      const anchor = rooms[0];
      const angle = Math.PI * (0.4 + Math.random() * 0.26) * (Math.random() < 0.5 ? 1 : -1);
      const distance = 120 + rooms.length * 18;
      const x = anchor.x + Math.cos(angle) * distance;
      const y = anchor.y + Math.sin(angle) * (distance * 0.9);
      const radius = 18 + Math.random() * 18;
      const width = VISUAL.tunnelBaseWidth + Math.random() * VISUAL.tunnelWidthVariance;
      const types = ["nursery", "storage", "larvae", "granary"];
      const newRoom = { x, y, radius, width: width + 1.5, type: types[Math.floor(Math.random() * types.length)] };
      rooms.push(newRoom);
      tunnels.push({ x1: anchor.x, y1: anchor.y, x2: newRoom.x, y2: newRoom.y, width });
      limitArraySize(tunnels, CONFIG.maxTunnels);
    }

    function updateQueen() {
      queen.layTimer--;
      if (queen.layTimer <= 0) {
        if (ants.length < CONFIG.maxAnts && colony.foodBank > 0) {
          colony.foodBank--;
          spawnAnt(queen.x + (Math.random() - 0.5) * 12, queen.y + (Math.random() - 0.5) * 12);
        }
        queen.layTimer = CONFIG.queenLayInterval + Math.random() * CONFIG.queenLayIntervalJitter;
      }
    }

    function updateAnts() {
      const minX = 6;
      const maxX = Math.max(minX, viewWidth - 6);
      const minY = surfaceHeight + 14;
      const maxY = Math.max(minY, viewHeight - 14);

      ants.forEach(ant => {
        if (ant.state === "explore") {
          let best = null;
          let bestStrength = 0;
          for (let i = pheromones.length - 1; i >= 0; i--) {
            const p = pheromones[i];
            const dx = p.x - ant.x;
            const dy = p.y - ant.y;
            const dist = Math.hypot(dx, dy);
            if (dist < CONFIG.pheromoneSenseDistance && p.strength > bestStrength) {
              best = p;
              bestStrength = p.strength;
            }
          }
          if (best) {
            ant.angle = Math.atan2(best.y - ant.y, best.x - ant.x);
            ant.angle += (Math.random() - 0.5) * (CONFIG.exploreTurnRate * 0.25);
          } else {
            ant.angle += (Math.random() - 0.5) * CONFIG.exploreTurnRate;
          }

          ant.x += Math.cos(ant.angle) * CONFIG.exploreSpeed;
          ant.y += Math.sin(ant.angle) * CONFIG.exploreSpeed;

          if (ant.y < minY) ant.y = minY;
          if (ant.x < minX) ant.x = minX;
          if (ant.x > maxX) ant.x = maxX;
          if (ant.y > maxY) ant.y = maxY;

          if (ant.trail.length === 0 || !ant.trailLastRecord) {
            ant.trail.push({ x: ant.x, y: ant.y });
            ant.trailLastRecord = { x: ant.x, y: ant.y };
          } else {
            const trailDx = ant.x - ant.trailLastRecord.x;
            const trailDy = ant.y - ant.trailLastRecord.y;
            if (Math.hypot(trailDx, trailDy) >= CONFIG.trailRecordDistance) {
              ant.trail.push({ x: ant.x, y: ant.y });
              ant.trailLastRecord = { x: ant.x, y: ant.y };
              if (ant.trail.length > CONFIG.trailMaxPoints) {
                ant.trail.shift();
              }
            }
          }

          if (Math.random() < 0.002) {
            const length = 12 + Math.random() * 18;
            const angle = ant.angle + (Math.random() - 0.5) * 0.5;
            const width = VISUAL.tunnelBaseWidth + Math.random() * VISUAL.tunnelWidthVariance;
            tunnels.push({
              x1: ant.x,
              y1: ant.y,
              x2: ant.x + Math.cos(angle) * length,
              y2: ant.y + Math.sin(angle) * length,
              width,
            });
            limitArraySize(tunnels, CONFIG.maxTunnels);
          }

          for (let i = foods.length - 1; i >= 0; i--) {
            const f = foods[i];
            if (f.amount <= 0) continue;
            const dist = Math.hypot(f.x - ant.x, f.y - ant.y);
            if (dist < f.radius + 3) {
              ant.carrying = true;
              ant.cargo = 1;
              ant.state = "return";
              ant.pathIndex = ant.trail.length - 1;
              f.amount--;
              if (f.amount <= 0) {
                foods.splice(i, 1);
              }
              break;
            }
          }
        } else {
          let targetX = queen.x;
          let targetY = queen.y;

          if (ant.pathIndex >= 0 && ant.pathIndex < ant.trail.length) {
            const waypoint = ant.trail[ant.pathIndex];
            targetX = waypoint.x;
            targetY = waypoint.y;
          }

          const dx = targetX - ant.x;
          const dy = targetY - ant.y;
          const dist = Math.hypot(dx, dy) || 1;
          ant.angle = Math.atan2(dy, dx);
          ant.x += (dx / dist) * CONFIG.returnSpeed;
          ant.y += (dy / dist) * CONFIG.returnSpeed;

          if (ant.x < minX) ant.x = minX;
          if (ant.x > maxX) ant.x = maxX;
          if (ant.y < minY) ant.y = minY;
          if (ant.y > maxY) ant.y = maxY;

          if (Math.random() < CONFIG.pheromoneDropChance) {
            dropPheromone(ant.x, ant.y);
          }

          if (ant.pathIndex >= 0 && dist < CONFIG.trailRecordDistance * 1.5) {
            ant.pathIndex--;
          }

          if (ant.pathIndex < 0) {
            const distToQueen = Math.hypot(queen.x - ant.x, queen.y - ant.y);
            if (distToQueen < 12) {
              ant.carrying = false;
              colony.foodBank += ant.cargo;
              colony.expansionProgress += ant.cargo;
              ant.cargo = 0;
              ant.state = "explore";
              ant.trail = [];
              ant.trailLastRecord = null;
              ant.pathIndex = -1;
              maybeExpandNest();
            }
          }
        }
      });
    }

    function drawSoil() {
      const surfaceGradient = ctx.createLinearGradient(0, 0, 0, surfaceHeight);
      surfaceGradient.addColorStop(0, "#4f3b2a");
      surfaceGradient.addColorStop(1, "#3d2c1f");
      ctx.fillStyle = surfaceGradient;
      ctx.fillRect(0, 0, viewWidth, surfaceHeight);

      const undergroundGradient = ctx.createLinearGradient(0, surfaceHeight, 0, viewHeight);
      undergroundGradient.addColorStop(0, "#2b1e15");
      undergroundGradient.addColorStop(0.35, "#22170f");
      undergroundGradient.addColorStop(1, "#1a120b");
      ctx.fillStyle = undergroundGradient;
      ctx.fillRect(0, surfaceHeight, viewWidth, viewHeight - surfaceHeight);

      ctx.save();
      ctx.lineWidth = 1;
      ctx.lineCap = "round";
      soilSpeckles.forEach(s => {
        ctx.save();
        ctx.translate(s.x, s.y);
        ctx.rotate(s.angle);
        ctx.globalAlpha = s.alpha;
        ctx.strokeStyle = "#170f09";
        ctx.beginPath();
        ctx.moveTo(-s.length / 2, 0);
        ctx.lineTo(s.length / 2, 0);
        ctx.lineWidth = s.thickness;
        ctx.stroke();
        ctx.restore();
      });
      ctx.restore();
    }

    function drawEntrance() {
      const entranceY = surfaceHeight - 6;
      const gradient = ctx.createRadialGradient(queen.x, entranceY, 0, queen.x, entranceY, 24);
      gradient.addColorStop(0, VISUAL.entranceGlow);
      gradient.addColorStop(1, "rgba(0, 0, 0, 0)");
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(queen.x, entranceY, 24, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#20160f";
      ctx.beginPath();
      ctx.arc(queen.x, surfaceHeight, 12, Math.PI, 2 * Math.PI);
      ctx.fill();
    }

    function drawTunnels() {
      ctx.save();
      ctx.strokeStyle = "#3b2a1d";
      ctx.lineCap = "round";
      tunnels.forEach(t => {
        ctx.beginPath();
        ctx.moveTo(t.x1, t.y1);
        ctx.lineTo(t.x2, t.y2);
        ctx.lineWidth = t.width;
        ctx.shadowColor = VISUAL.tunnelShadow;
        ctx.shadowBlur = 6;
        ctx.stroke();
      });
      ctx.restore();
    }

    function drawRooms() {
      rooms.forEach(r => {
        const gradient = ctx.createRadialGradient(r.x, r.y, r.radius * 0.15, r.x, r.y, r.radius);
        gradient.addColorStop(0, VISUAL.roomHighlight);
        gradient.addColorStop(0.7, "rgba(68, 51, 36, 0.95)");
        gradient.addColorStop(1, "rgba(40, 29, 21, 1)");
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = "rgba(18, 12, 8, 0.6)";
        ctx.lineWidth = 2;
        ctx.stroke();
      });
    }

    function drawPheromones() {
      pheromones.forEach(p => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 1.8, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(0, 200, 220, ${p.strength})`;
        ctx.fill();
      });
    }

    function drawFoods() {
      foods.forEach(f => {
        const amountRatio = Math.max(0.2, f.amount / CONFIG.foodClusterMax);
        ctx.beginPath();
        ctx.arc(f.x, f.y, Math.max(2.4, f.radius * amountRatio), 0, Math.PI * 2);
        ctx.fillStyle = "#24ff41";
        ctx.shadowColor = "rgba(36, 255, 65, 0.4)";
        ctx.shadowBlur = 8;
        ctx.fill();
        ctx.shadowBlur = 0;
      });
    }

    function drawQueenAura() {
      const gradient = ctx.createRadialGradient(queen.x, queen.y, 0, queen.x, queen.y, 48);
      gradient.addColorStop(0, VISUAL.queenAuraColor);
      gradient.addColorStop(1, "rgba(0, 0, 0, 0)");
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(queen.x, queen.y, 48, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawQueen() {
      ctx.beginPath();
      ctx.arc(queen.x, queen.y, 7.4, 0, Math.PI * 2);
      ctx.fillStyle = "#ff4dd2";
      ctx.shadowColor = "rgba(255, 77, 210, 0.6)";
      ctx.shadowBlur = 12;
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    function drawAnts() {
      ants.forEach(ant => {
        ctx.beginPath();
        ctx.arc(ant.x, ant.y, ant.carrying ? 2.8 : 2.2, 0, Math.PI * 2);
        ctx.fillStyle = ant.carrying ? "#ffe066" : "#f5f5f5";
        ctx.fill();
      });
    }

    function draw() {
      ctx.clearRect(0, 0, viewWidth, viewHeight);
      drawSoil();
      drawEntrance();
      drawTunnels();
      drawRooms();
      drawPheromones();
      drawFoods();
      drawQueenAura();
      drawQueen();
      drawAnts();
    }

    function updateHud() {
      hud.innerHTML = `
        <strong>女王</strong> 体力: ${colony.foodBank.toString().padStart(2, "0")} / 巣部屋: ${rooms.length}<br>
        アリ: ${ants.length} / ${CONFIG.maxAnts}　フェロモン: ${pheromones.length}　食料源: ${foods.length}
      `;
    }

    function resizeCanvas(initial = false) {
      const prevWidth = viewWidth || window.innerWidth;
      const prevHeight = viewHeight || window.innerHeight;
      const dpr = window.devicePixelRatio || 1;

      viewWidth = window.innerWidth;
      viewHeight = window.innerHeight;
      surfaceHeight = viewHeight * 0.15;

      canvas.style.width = `${viewWidth}px`;
      canvas.style.height = `${viewHeight}px`;
      canvas.width = viewWidth * dpr;
      canvas.height = viewHeight * dpr;
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.scale(dpr, dpr);

      if (initial) {
        queen.x = viewWidth / 2;
        queen.y = surfaceHeight + 60;
        generateSoilTexture();
        return;
      }

      const scaleX = viewWidth / prevWidth;
      const scaleY = viewHeight / prevHeight;
      const scaleAvg = (scaleX + scaleY) * 0.5;

      ants.forEach(ant => {
        ant.x *= scaleX;
        ant.y *= scaleY;
      });
      tunnels.forEach(t => {
        t.x1 *= scaleX;
        t.y1 *= scaleY;
        t.x2 *= scaleX;
        t.y2 *= scaleY;
        t.width *= scaleAvg;
      });
      rooms.forEach(r => {
        r.x *= scaleX;
        r.y *= scaleY;
        r.radius *= scaleAvg;
        r.width *= scaleAvg;
      });
      pheromones.forEach(p => {
        p.x *= scaleX;
        p.y *= scaleY;
      });
      foods.forEach(f => {
        f.x *= scaleX;
        f.y *= scaleY;
        f.radius *= scaleAvg;
      });

      queen.x *= scaleX;
      queen.y = surfaceHeight + 60;
      generateSoilTexture();
    }

    function animate() {
      updateQueen();
      updateAnts();
      updatePheromones();
      updateFoodSpawning();
      draw();
      updateHud();
      requestAnimationFrame(animate);
    }

    function bootstrap() {
      resizeCanvas(true);
      initializeNest();
      for (let i = 0; i < CONFIG.initialAnts; i++) {
        spawnAnt(queen.x + (Math.random() - 0.5) * 30, queen.y + (Math.random() - 0.5) * 30);
      }
      for (let i = 0; i < 2; i++) {
        spawnFoodSource();
      }
      draw();
      updateHud();
      animate();
    }

    window.addEventListener("resize", () => resizeCanvas(false));
    bootstrap();
  </script>
</body>
</html>
